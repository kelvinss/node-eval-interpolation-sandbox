// Generated by CoffeeScript 1.10.0
(function() {
  var ParserAsync, ParserSync, asyncReplace, clone, escapeRegExp, objTypeof, vm,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  try {
    require("source-map-support").install();
  } catch (undefined) {}

  vm = require("vm");

  clone = require("clone");

  asyncReplace = require("async-replace");

  objTypeof = function(obj) {
    return Object.prototype.toString.call(obj);
  };

  escapeRegExp = function(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  };

  ParserAsync = (function() {
    function ParserAsync(opts) {
      var ref, ref1, ref2;
      if (opts == null) {
        opts = {};
      }
      this.parseTemplate = bind(this.parseTemplate, this);
      this.handleCode = bind(this.handleCode, this);
      this.evalCodeInContext = bind(this.evalCodeInContext, this);
      this.makePatt = bind(this.makePatt, this);
      this.sandbox = (ref = opts.sandbox) != null ? ref : 0, this.ignore = (ref1 = opts.ignore) != null ? ref1 : 0, this.delimiter = (ref2 = opts.delimiter) != null ? ref2 : "`";
      this.makePatt();
    }

    Object.defineProperties(ParserAsync.prototype, {
      delimiter: {
        get: function() {
          return [this.leftDelimiter, this.rightDelimiter];
        },
        set: function(delimiter) {
          if (objTypeof(delimiter) === "[object String]") {
            return this.leftDelimiter = this.rightDelimiter = delimiter;
          } else if (objTypeof(delimiter) === "[object Array]" && delimiter.length === 2) {
            return this.leftDelimiter = delimiter[0], this.rightDelimiter = delimiter[1], delimiter;
          } else {
            throw new TypeError("delimiter must be an string or list with 2 items");
          }
        }
      }
    });

    ParserAsync.prototype.makePatt = function(delimiter) {
      if (delimiter == null) {
        delimiter = this.delimiter;
      }
      delimiter = delimiter.map(escapeRegExp);
      return this._patt = new RegExp(delimiter[0] + "(.*?)" + delimiter[1], "g");
    };

    ParserAsync.prototype.evalCodeInContext = function(context, code) {
      return new vm.Script(code).runInNewContext(context);
    };

    ParserAsync.prototype.handleCode = function(code, context, callback) {
      var err, error, res;
      try {
        res = this.evalCodeInContext(context, code);
        return typeof callback === "function" ? callback(null, res) : void 0;
      } catch (error) {
        err = error;
        return typeof callback === "function" ? callback(err) : void 0;
      }
    };

    ParserAsync.prototype.parseTemplate = function() {
      var _context, callback, delimiter, errors, i, ignore, opts, patt, ref, ref1, ref2, replacer, sandbox, strg;
      strg = arguments[0], _context = arguments[1], opts = 4 <= arguments.length ? slice.call(arguments, 2, i = arguments.length - 1) : (i = 2, []), callback = arguments[i++];
      opts = opts[0] || {};
      sandbox = (ref = opts.sandbox) != null ? ref : this.sandbox, ignore = (ref1 = opts.ignore) != null ? ref1 : this.ignore, delimiter = (ref2 = opts.delimiter) != null ? ref2 : this.delimiter;
      if (objTypeof(delimiter) === "[object String]") {
        delimiter = [delimiter, delimiter];
      } else if (!(objTypeof(delimiter) === "[object Array]" && delimiter.length === 2)) {
        return callback(new TypeError("delimiter must be an string or list with 2 items"));
      }
      patt = this.makePatt(delimiter);
      errors = [];
      replacer = (function(_this) {
        return function(match, p1, o, strg, cb) {
          var context;
          context = sandbox ? clone(_context) : _context;
          return _this.handleCode(p1, context, function(err, res) {
            if (err) {
              errors.push(err);
            }
            if (ignore) {
              return cb(null, res);
            } else {
              return cb(err, res);
            }
          });
        };
      })(this);
      return asyncReplace(strg, patt, replacer, function(err, res) {
        err || (err = errors || void 0);
        return typeof callback === "function" ? callback(err, res) : void 0;
      });
    };

    return ParserAsync;

  })();

  ParserSync = (function(superClass) {
    extend(ParserSync, superClass);

    function ParserSync() {
      this.parseTemplate = bind(this.parseTemplate, this);
      this.handleCode = bind(this.handleCode, this);
      return ParserSync.__super__.constructor.apply(this, arguments);
    }

    ParserSync.prototype.handleCode = function(code, context) {
      return this.evalCodeInContext(context, code);
    };

    ParserSync.prototype.parseTemplate = function(strg, _context, opts) {
      var delimiter, patt, ref, ref1, replacer, sandbox;
      if (opts == null) {
        opts = {};
      }
      sandbox = (ref = opts.sandbox) != null ? ref : this.sandbox, delimiter = (ref1 = opts.delimiter) != null ? ref1 : this.delimiter;
      if (objTypeof(delimiter) === "[object String]") {
        delimiter = [delimiter, delimiter];
      } else if (!(objTypeof(delimiter) === "[object Array]" && delimiter.length === 2)) {
        throw new TypeError("delimiter must be an string or list with 2 items");
      }
      patt = this.makePatt(delimiter);
      replacer = (function(_this) {
        return function(match, p1, o, strg) {
          var context;
          context = sandbox ? clone(_context) : _context;
          return _this.handleCode(p1, context);
        };
      })(this);
      return strg.replace(patt, replacer);
    };

    return ParserSync;

  })(ParserAsync);

  module.exports = new ParserSync().parseTemplate;

  module.exports.ParserAsync = ParserAsync;

  module.exports.ParserSync = ParserSync;

  module.exports.Parser = ParserSync;

}).call(this);

//# sourceMappingURL=index.js.map
